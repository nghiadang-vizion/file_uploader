{"ast":null,"code":"var binary = require('binary');\nvar PullStream = require('../PullStream');\nvar unzip = require('./unzip');\nvar Promise = require('bluebird');\nvar BufferStream = require('../BufferStream');\nvar parseExtraField = require('../parseExtraField');\nvar Buffer = require('../Buffer');\nvar path = require('path');\nvar Writer = require('fstream').Writer;\nvar parseDateTime = require('../parseDateTime');\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50, 0);\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n  return sourceStream.pull(4).then(function (data) {\n    var signature = data.readUInt32LE(0);\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function (data) {\n        crxHeader = binary.parse(data).word32lu('version').word32lu('pubKeyLength').word32lu('signatureLength').vars;\n      }).then(function () {\n        return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);\n      }).then(function (data) {\n        crxHeader.publicKey = data.slice(0, crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL).word32lu('signature').word32lu('diskNumber').word64lu('offsetToStartOfCentralDirectory').word32lu('numberOfDisks').vars;\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n  return dir64.pull(56);\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction parseZip64DirRecord(dir64record) {\n  var vars = binary.parse(dir64record).word32lu('signature').word64lu('sizeOfCentralDirectory').word16lu('version').word16lu('versionsNeededToExtract').word32lu('diskNumber').word32lu('diskStart').word64lu('numberOfRecordsOnDisk').word64lu('numberOfRecords').word64lu('sizeOfCentralDirectory').word64lu('offsetToStartOfCentralDirectory').vars;\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n  return vars;\n}\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n    records = PullStream(),\n    tailSize = options && options.tailSize || 80,\n    sourceSize,\n    crxHeader,\n    startOffset,\n    vars;\n  if (options && options.crx) crxHeader = getCrxHeader(source);\n  return source.size().then(function (size) {\n    sourceSize = size;\n    source.stream(Math.max(0, size - tailSize)).on('error', function (error) {\n      endDir.emit('error', error);\n    }).pipe(endDir);\n    return endDir.pull(signature);\n  }).then(function () {\n    return Promise.props({\n      directory: endDir.pull(22),\n      crxHeader: crxHeader\n    });\n  }).then(function (d) {\n    var data = d.directory;\n    startOffset = d.crxHeader && d.crxHeader.size || 0;\n    vars = binary.parse(data).word32lu('signature').word16lu('diskNumber').word16lu('diskStart').word16lu('numberOfRecordsOnDisk').word16lu('numberOfRecords').word32lu('sizeOfCentralDirectory').word32lu('offsetToStartOfCentralDirectory').word16lu('commentLength').vars;\n\n    // Is this zip file using zip64 format? Use same check as Go:\n    // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n    // For zip64 files, need to find zip64 central directory locator header to extract\n    // relative offset for zip64 central directory record.\n    if (vars.numberOfRecords == 0xffff || vars.numberOfRecords == 0xffff || vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n      // Offset to zip64 CDL is 20 bytes before normal CDR\n      const zip64CDLSize = 20;\n      const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);\n      const zip64CDLStream = PullStream();\n      source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n      return zip64CDLStream.pull(zip64CDLSize).then(function (d) {\n        return getZip64CentralDirectory(source, d);\n      }).then(function (dir64record) {\n        vars = parseZip64DirRecord(dir64record);\n      });\n    } else {\n      vars.offsetToStartOfCentralDirectory += startOffset;\n    }\n  }).then(function () {\n    if (vars.commentLength) return endDir.pull(vars.commentLength).then(function (comment) {\n      vars.comment = comment.toString('utf8');\n    });\n  }).then(function () {\n    source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n    vars.extract = function (opts) {\n      if (!opts || !opts.path) throw new Error('PATH_MISSING');\n      // make sure path is normalized before using it\n      opts.path = path.resolve(path.normalize(opts.path));\n      return vars.files.then(function (files) {\n        return Promise.map(files, function (entry) {\n          if (entry.type == 'Directory') return;\n\n          // to avoid zip slip (writing outside of the destination), we resolve\n          // the target path, and make sure it's nested in the intended\n          // destination, or not extract it otherwise.\n          var extractPath = path.join(opts.path, entry.path);\n          if (extractPath.indexOf(opts.path) != 0) {\n            return;\n          }\n          var writer = opts.getWriter ? opts.getWriter({\n            path: extractPath\n          }) : Writer({\n            path: extractPath\n          });\n          return new Promise(function (resolve, reject) {\n            entry.stream(opts.password).on('error', reject).pipe(writer).on('close', resolve).on('error', reject);\n          });\n        }, {\n          concurrency: opts.concurrency > 1 ? opts.concurrency : 1\n        });\n      });\n    };\n    vars.files = Promise.mapSeries(Array(vars.numberOfRecords), function () {\n      return records.pull(46).then(function (data) {\n        var vars = binary.parse(data).word32lu('signature').word16lu('versionMadeBy').word16lu('versionsNeededToExtract').word16lu('flags').word16lu('compressionMethod').word16lu('lastModifiedTime').word16lu('lastModifiedDate').word32lu('crc32').word32lu('compressedSize').word32lu('uncompressedSize').word16lu('fileNameLength').word16lu('extraFieldLength').word16lu('fileCommentLength').word16lu('diskNumber').word16lu('internalFileAttributes').word32lu('externalFileAttributes').word32lu('offsetToLocalFileHeader').vars;\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n        return records.pull(vars.fileNameLength).then(function (fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = (vars.flags & 0x800) != 0;\n          return records.pull(vars.extraFieldLength);\n        }).then(function (extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        }).then(function (comment) {\n          vars.comment = comment;\n          vars.type = vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path) ? 'Directory' : 'File';\n          vars.stream = function (_password) {\n            return unzip(source, vars.offsetToLocalFileHeader, _password, vars);\n          };\n          vars.buffer = function (_password) {\n            return BufferStream(vars.stream(_password));\n          };\n          return vars;\n        });\n      });\n    });\n    return Promise.props(vars);\n  });\n};","map":{"version":3,"names":["binary","require","PullStream","unzip","Promise","BufferStream","parseExtraField","Buffer","path","Writer","parseDateTime","signature","alloc","writeUInt32LE","getCrxHeader","source","sourceStream","stream","pipe","pull","then","data","readUInt32LE","crxHeader","parse","word32lu","vars","pubKeyLength","signatureLength","publicKey","slice","size","getZip64CentralDirectory","zip64CDL","d64loc","word64lu","Error","toString","dir64","offsetToStartOfCentralDirectory","parseZip64DirRecord","dir64record","word16lu","module","exports","centralDirectory","options","endDir","records","tailSize","sourceSize","startOffset","crx","Math","max","on","error","emit","props","directory","d","numberOfRecords","zip64CDLSize","zip64CDLOffset","match","zip64CDLStream","commentLength","comment","extract","opts","resolve","normalize","files","map","entry","type","extractPath","join","indexOf","writer","getWriter","reject","password","concurrency","mapSeries","Array","offsetToLocalFileHeader","lastModifiedDateTime","lastModifiedDate","lastModifiedTime","fileNameLength","fileNameBuffer","pathBuffer","isUnicode","flags","extraFieldLength","extraField","extra","fileCommentLength","uncompressedSize","test","_password","buffer"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/unzipper/lib/Open/directory.js"],"sourcesContent":["var binary = require('binary');\nvar PullStream = require('../PullStream');\nvar unzip = require('./unzip');\nvar Promise = require('bluebird');\nvar BufferStream = require('../BufferStream');\nvar parseExtraField = require('../parseExtraField');\nvar Buffer = require('../Buffer');\nvar path = require('path');\nvar Writer = require('fstream').Writer;\nvar parseDateTime = require('../parseDateTime');\n\nvar signature = Buffer.alloc(4);\nsignature.writeUInt32LE(0x06054b50,0);\n\nfunction getCrxHeader(source) {\n  var sourceStream = source.stream(0).pipe(PullStream());\n\n  return sourceStream.pull(4).then(function(data) {\n    var signature = data.readUInt32LE(0);\n    if (signature === 0x34327243) {\n      var crxHeader;\n      return sourceStream.pull(12).then(function(data) {\n        crxHeader = binary.parse(data)\n          .word32lu('version')\n          .word32lu('pubKeyLength')\n          .word32lu('signatureLength')\n          .vars;\n      }).then(function() {\n        return sourceStream.pull(crxHeader.pubKeyLength +crxHeader.signatureLength);\n      }).then(function(data) {\n        crxHeader.publicKey = data.slice(0,crxHeader.pubKeyLength);\n        crxHeader.signature = data.slice(crxHeader.pubKeyLength);\n        crxHeader.size = 16 + crxHeader.pubKeyLength +crxHeader.signatureLength;\n        return crxHeader;\n      });\n    }\n  });\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction getZip64CentralDirectory(source, zip64CDL) {\n  var d64loc = binary.parse(zip64CDL)\n    .word32lu('signature')\n    .word32lu('diskNumber')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .word32lu('numberOfDisks')\n    .vars;\n\n  if (d64loc.signature != 0x07064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x07064b50): 0x' + d64loc.signature.toString(16));\n  }\n\n  var dir64 = PullStream();\n  source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);\n\n  return dir64.pull(56)\n}\n\n// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT\nfunction parseZip64DirRecord (dir64record) {\n  var vars = binary.parse(dir64record)\n    .word32lu('signature')\n    .word64lu('sizeOfCentralDirectory')\n    .word16lu('version')\n    .word16lu('versionsNeededToExtract')\n    .word32lu('diskNumber')\n    .word32lu('diskStart')\n    .word64lu('numberOfRecordsOnDisk')\n    .word64lu('numberOfRecords')\n    .word64lu('sizeOfCentralDirectory')\n    .word64lu('offsetToStartOfCentralDirectory')\n    .vars;\n\n  if (vars.signature != 0x06064b50) {\n    throw new Error('invalid zip64 end of central dir locator signature (0x06064b50): 0x0' + vars.signature.toString(16));\n  }\n\n  return vars\n}\n\nmodule.exports = function centralDirectory(source, options) {\n  var endDir = PullStream(),\n      records = PullStream(),\n      tailSize = (options && options.tailSize) || 80,\n      sourceSize,\n      crxHeader,\n      startOffset,\n      vars;\n\n  if (options && options.crx)\n    crxHeader = getCrxHeader(source);\n\n  return source.size()\n    .then(function(size) {\n      sourceSize = size;\n\n      source.stream(Math.max(0,size-tailSize))\n        .on('error', function (error) { endDir.emit('error', error) })\n        .pipe(endDir);\n\n      return endDir.pull(signature);\n    })\n    .then(function() {\n      return Promise.props({directory: endDir.pull(22), crxHeader: crxHeader});\n    })\n    .then(function(d) {\n      var data = d.directory;\n      startOffset = d.crxHeader && d.crxHeader.size || 0;\n\n      vars = binary.parse(data)\n        .word32lu('signature')\n        .word16lu('diskNumber')\n        .word16lu('diskStart')\n        .word16lu('numberOfRecordsOnDisk')\n        .word16lu('numberOfRecords')\n        .word32lu('sizeOfCentralDirectory')\n        .word32lu('offsetToStartOfCentralDirectory')\n        .word16lu('commentLength')\n        .vars;\n\n      // Is this zip file using zip64 format? Use same check as Go:\n      // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503\n      // For zip64 files, need to find zip64 central directory locator header to extract\n      // relative offset for zip64 central directory record.\n      if (vars.numberOfRecords == 0xffff|| vars.numberOfRecords == 0xffff ||\n        vars.offsetToStartOfCentralDirectory == 0xffffffff) {\n\n        // Offset to zip64 CDL is 20 bytes before normal CDR\n        const zip64CDLSize = 20\n        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize)\n        const zip64CDLStream = PullStream();\n\n        source.stream(zip64CDLOffset).pipe(zip64CDLStream);\n\n        return zip64CDLStream.pull(zip64CDLSize)\n          .then(function (d) { return getZip64CentralDirectory(source, d) })\n          .then(function (dir64record) {\n            vars = parseZip64DirRecord(dir64record)\n          })\n      } else {\n        vars.offsetToStartOfCentralDirectory += startOffset;\n      }\n    })\n    .then(function() {\n      if (vars.commentLength) return endDir.pull(vars.commentLength).then(function(comment) {\n        vars.comment = comment.toString('utf8');\n      });\n    })\n    .then(function() {\n      source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);\n\n      vars.extract = function(opts) {\n        if (!opts || !opts.path) throw new Error('PATH_MISSING');\n        // make sure path is normalized before using it\n        opts.path = path.resolve(path.normalize(opts.path));\n        return vars.files.then(function(files) {\n          return Promise.map(files, function(entry) {\n            if (entry.type == 'Directory') return;\n\n            // to avoid zip slip (writing outside of the destination), we resolve\n            // the target path, and make sure it's nested in the intended\n            // destination, or not extract it otherwise.\n            var extractPath = path.join(opts.path, entry.path);\n            if (extractPath.indexOf(opts.path) != 0) {\n              return;\n            }\n            var writer = opts.getWriter ? opts.getWriter({path: extractPath}) :  Writer({ path: extractPath });\n\n            return new Promise(function(resolve, reject) {\n              entry.stream(opts.password)\n                .on('error',reject)\n                .pipe(writer)\n                .on('close',resolve)\n                .on('error',reject);\n            });\n          }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });\n        });\n      };\n\n      vars.files = Promise.mapSeries(Array(vars.numberOfRecords),function() {\n        return records.pull(46).then(function(data) {    \n          var vars = binary.parse(data)\n            .word32lu('signature')\n            .word16lu('versionMadeBy')\n            .word16lu('versionsNeededToExtract')\n            .word16lu('flags')\n            .word16lu('compressionMethod')\n            .word16lu('lastModifiedTime')\n            .word16lu('lastModifiedDate')\n            .word32lu('crc32')\n            .word32lu('compressedSize')\n            .word32lu('uncompressedSize')\n            .word16lu('fileNameLength')\n            .word16lu('extraFieldLength')\n            .word16lu('fileCommentLength')\n            .word16lu('diskNumber')\n            .word16lu('internalFileAttributes')\n            .word32lu('externalFileAttributes')\n            .word32lu('offsetToLocalFileHeader')\n            .vars;\n\n        vars.offsetToLocalFileHeader += startOffset;\n        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);\n\n        return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {\n          vars.pathBuffer = fileNameBuffer;\n          vars.path = fileNameBuffer.toString('utf8');\n          vars.isUnicode = (vars.flags & 0x800) != 0;\n          return records.pull(vars.extraFieldLength);\n        })\n        .then(function(extraField) {\n          vars.extra = parseExtraField(extraField, vars);\n          return records.pull(vars.fileCommentLength);\n        })\n        .then(function(comment) {\n          vars.comment = comment;\n          vars.type = (vars.uncompressedSize === 0 && /[\\/\\\\]$/.test(vars.path)) ? 'Directory' : 'File';\n          vars.stream = function(_password) {\n            return unzip(source, vars.offsetToLocalFileHeader,_password, vars);\n          };\n          vars.buffer = function(_password) {\n            return BufferStream(vars.stream(_password));\n          };\n          return vars;\n        });\n      });\n    });\n\n    return Promise.props(vars);\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}