{"ast":null,"code":"module.exports = LinkWriter;\nvar fs = require('graceful-fs');\nvar Writer = require('./writer.js');\nvar inherits = require('inherits');\nvar path = require('path');\nvar rimraf = require('rimraf');\ninherits(LinkWriter, Writer);\nfunction LinkWriter(props) {\n  var self = this;\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.');\n  }\n\n  // should already be established as a Link type\n  if (!(props.type === 'Link' && props.Link || props.type === 'SymbolicLink' && props.SymbolicLink)) {\n    throw new Error('Non-link type ' + props.type);\n  }\n  if (props.linkpath === '') props.linkpath = '.';\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type);\n  }\n  Writer.call(this, props);\n}\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this;\n  var hard = self.type === 'Link' || process.platform === 'win32';\n  var link = hard ? 'link' : 'symlink';\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath;\n\n  // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n  if (hard) return clobber(self, lp, link);\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self);\n    clobber(self, lp, link);\n  });\n};\nfunction clobber(self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er);\n    create(self, lp, link);\n  });\n}\nfunction create(self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' || er.code === 'EACCES' || er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true;\n        self.emit('ready');\n        self.emit('end');\n        self.emit('close');\n        self.end = self._finish = function () {};\n      } else return self.error(er);\n    }\n    finish(self);\n  });\n}\nfunction finish(self) {\n  self.ready = true;\n  self.emit('ready');\n  if (self._ended && !self._finished) self._finish();\n}\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true;\n  if (this.ready) {\n    this._finished = true;\n    this._finish();\n  }\n};","map":{"version":3,"names":["module","exports","LinkWriter","fs","require","Writer","inherits","path","rimraf","props","self","Error","type","Link","SymbolicLink","linkpath","error","call","prototype","_create","hard","process","platform","link","lp","resolve","dirname","clobber","readlink","_path","er","p","finish","create","code","ready","emit","end","_finish","_ended","_finished"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/fstream/lib/link-writer.js"],"sourcesContent":["module.exports = LinkWriter\n\nvar fs = require('graceful-fs')\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar path = require('path')\nvar rimraf = require('rimraf')\n\ninherits(LinkWriter, Writer)\n\nfunction LinkWriter (props) {\n  var self = this\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.')\n  }\n\n  // should already be established as a Link type\n  if (!((props.type === 'Link' && props.Link) ||\n    (props.type === 'SymbolicLink' && props.SymbolicLink))) {\n    throw new Error('Non-link type ' + props.type)\n  }\n\n  if (props.linkpath === '') props.linkpath = '.'\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type)\n  }\n\n  Writer.call(this, props)\n}\n\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this\n  var hard = self.type === 'Link' || process.platform === 'win32'\n  var link = hard ? 'link' : 'symlink'\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath\n\n  // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n  if (hard) return clobber(self, lp, link)\n\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self)\n    clobber(self, lp, link)\n  })\n}\n\nfunction clobber (self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er)\n    create(self, lp, link)\n  })\n}\n\nfunction create (self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' ||\n        er.code === 'EACCES' ||\n        er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true\n        self.emit('ready')\n        self.emit('end')\n        self.emit('close')\n        self.end = self._finish = function () {}\n      } else return self.error(er)\n    }\n    finish(self)\n  })\n}\n\nfunction finish (self) {\n  self.ready = true\n  self.emit('ready')\n  if (self._ended && !self._finished) self._finish()\n}\n\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true\n  if (this.ready) {\n    this._finished = true\n    this._finish()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}