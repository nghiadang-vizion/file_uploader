{"ast":null,"code":"// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter;\nvar Writer = require('./writer.js');\nvar inherits = require('inherits');\nvar mkdir = require('mkdirp');\nvar path = require('path');\nvar collect = require('./collect.js');\ninherits(DirWriter, Writer);\nfunction DirWriter(props) {\n  var self = this;\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true);\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' + JSON.stringify(props), null, true);\n  }\n  Writer.call(this, props);\n}\nDirWriter.prototype._create = function () {\n  var self = this;\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er);\n    // ready to start getting entries!\n    self.ready = true;\n    self.emit('ready');\n    self._process();\n  });\n};\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true;\n};\nDirWriter.prototype.end = function () {\n  this._ended = true;\n  this._process();\n};\nDirWriter.prototype.add = function (entry) {\n  var self = this;\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry);\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry);\n    return false;\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end');\n  }\n  self._buffer.push(entry);\n  self._process();\n  return this._buffer.length === 0;\n};\nDirWriter.prototype._process = function () {\n  var self = this;\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return;\n  var entry = self._buffer.shift();\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain');\n    if (self._ended) self._finish();\n    return;\n  }\n  self._processing = true;\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry);\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry;\n  var pp;\n  do {\n    pp = p._path || p.path;\n    if (pp === self.root._path || pp === self._path || pp && pp.indexOf(self._path) === 0) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false;\n      if (entry._collected) entry.pipe();\n      return self._process();\n    }\n    p = p.parent;\n  } while (p);\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  };\n  pp = entry._path || entry.path || entry.props.path;\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1);\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp));\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter;\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k];\n    }\n  });\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props);\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child);\n    entry.resume();\n  });\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er);\n      child.emit('end');\n      child.emit('close');\n    } else {\n      self.emit('error', er);\n    }\n  });\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend);\n  var ended = false;\n  function onend() {\n    if (ended) return;\n    ended = true;\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null;\n    self._processing = false;\n    self._process();\n  }\n};","map":{"version":3,"names":["module","exports","DirWriter","Writer","require","inherits","mkdir","path","collect","props","self","error","type","Directory","JSON","stringify","call","prototype","_create","_path","dirmode","er","ready","emit","_process","write","end","_ended","add","entry","_currentEntry","_buffer","push","length","_processing","shift","_finish","p","pp","root","indexOf","_collected","pipe","parent","depth","substr","join","filter","Object","keys","forEach","k","hasOwnProperty","child","_currentChild","on","resume","_swallowErrors","warn","onend","ended"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/fstream/lib/dir-writer.js"],"sourcesContent":["// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar mkdir = require('mkdirp')\nvar path = require('path')\nvar collect = require('./collect.js')\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var self = this\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true)\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' +\n      JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var self = this\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er)\n    // ready to start getting entries!\n    self.ready = true\n    self.emit('ready')\n    self._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var self = this\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry)\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end')\n  }\n\n  self._buffer.push(entry)\n  self._process()\n\n  return this._buffer.length === 0\n}\n\nDirWriter.prototype._process = function () {\n  var self = this\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return\n\n  var entry = self._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain')\n    if (self._ended) self._finish()\n    return\n  }\n\n  self._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  var pp\n  do {\n    pp = p._path || p.path\n    if (pp === self.root._path || pp === self._path ||\n      (pp && pp.indexOf(self._path) === 0)) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false\n      if (entry._collected) entry.pipe()\n      return self._process()\n    }\n    p = p.parent\n  } while (p)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  }\n\n  pp = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props)\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er)\n      child.emit('end')\n      child.emit('close')\n    } else {\n      self.emit('error', er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null\n    self._processing = false\n    self._process()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}