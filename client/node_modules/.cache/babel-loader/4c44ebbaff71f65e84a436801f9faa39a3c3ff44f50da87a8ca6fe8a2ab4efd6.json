{"ast":null,"code":"var Chainsaw = require('chainsaw');\nvar EventEmitter = require('events').EventEmitter;\nvar Buffers = require('buffers');\nvar Vars = require('./lib/vars.js');\nvar Stream = require('stream').Stream;\nexports = module.exports = function (bufOrEm, eventName) {\n  if (Buffer.isBuffer(bufOrEm)) {\n    return exports.parse(bufOrEm);\n  }\n  var s = exports.stream();\n  if (bufOrEm && bufOrEm.pipe) {\n    bufOrEm.pipe(s);\n  } else if (bufOrEm) {\n    bufOrEm.on(eventName || 'data', function (buf) {\n      s.write(buf);\n    });\n    bufOrEm.on('end', function () {\n      s.end();\n    });\n  }\n  return s;\n};\nexports.stream = function (input) {\n  if (input) return exports.apply(null, arguments);\n  var pending = null;\n  function getBytes(bytes, cb, skip) {\n    pending = {\n      bytes: bytes,\n      skip: skip,\n      cb: function (buf) {\n        pending = null;\n        cb(buf);\n      }\n    };\n    dispatch();\n  }\n  var offset = null;\n  function dispatch() {\n    if (!pending) {\n      if (caughtEnd) done = true;\n      return;\n    }\n    if (typeof pending === 'function') {\n      pending();\n    } else {\n      var bytes = offset + pending.bytes;\n      if (buffers.length >= bytes) {\n        var buf;\n        if (offset == null) {\n          buf = buffers.splice(0, bytes);\n          if (!pending.skip) {\n            buf = buf.slice();\n          }\n        } else {\n          if (!pending.skip) {\n            buf = buffers.slice(offset, bytes);\n          }\n          offset = bytes;\n        }\n        if (pending.skip) {\n          pending.cb();\n        } else {\n          pending.cb(buf);\n        }\n      }\n    }\n  }\n  function builder(saw) {\n    function next() {\n      if (!done) saw.next();\n    }\n    var self = words(function (bytes, cb) {\n      return function (name) {\n        getBytes(bytes, function (buf) {\n          vars.set(name, cb(buf));\n          next();\n        });\n      };\n    });\n    self.tap = function (cb) {\n      saw.nest(cb, vars.store);\n    };\n    self.into = function (key, cb) {\n      if (!vars.get(key)) vars.set(key, {});\n      var parent = vars;\n      vars = Vars(parent.get(key));\n      saw.nest(function () {\n        cb.apply(this, arguments);\n        this.tap(function () {\n          vars = parent;\n        });\n      }, vars.store);\n    };\n    self.flush = function () {\n      vars.store = {};\n      next();\n    };\n    self.loop = function (cb) {\n      var end = false;\n      saw.nest(false, function loop() {\n        this.vars = vars.store;\n        cb.call(this, function () {\n          end = true;\n          next();\n        }, vars.store);\n        this.tap(function () {\n          if (end) saw.next();else loop.call(this);\n        }.bind(this));\n      }, vars.store);\n    };\n    self.buffer = function (name, bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n      getBytes(bytes, function (buf) {\n        vars.set(name, buf);\n        next();\n      });\n    };\n    self.skip = function (bytes) {\n      if (typeof bytes === 'string') {\n        bytes = vars.get(bytes);\n      }\n      getBytes(bytes, function () {\n        next();\n      });\n    };\n    self.scan = function find(name, search) {\n      if (typeof search === 'string') {\n        search = new Buffer(search);\n      } else if (!Buffer.isBuffer(search)) {\n        throw new Error('search must be a Buffer or a string');\n      }\n      var taken = 0;\n      pending = function () {\n        var pos = buffers.indexOf(search, offset + taken);\n        var i = pos - offset - taken;\n        if (pos !== -1) {\n          pending = null;\n          if (offset != null) {\n            vars.set(name, buffers.slice(offset, offset + taken + i));\n            offset += taken + i + search.length;\n          } else {\n            vars.set(name, buffers.slice(0, taken + i));\n            buffers.splice(0, taken + i + search.length);\n          }\n          next();\n          dispatch();\n        } else {\n          i = Math.max(buffers.length - search.length - offset - taken, 0);\n        }\n        taken += i;\n      };\n      dispatch();\n    };\n    self.peek = function (cb) {\n      offset = 0;\n      saw.nest(function () {\n        cb.call(this, vars.store);\n        this.tap(function () {\n          offset = null;\n        });\n      });\n    };\n    return self;\n  }\n  ;\n  var stream = Chainsaw.light(builder);\n  stream.writable = true;\n  var buffers = Buffers();\n  stream.write = function (buf) {\n    buffers.push(buf);\n    dispatch();\n  };\n  var vars = Vars();\n  var done = false,\n    caughtEnd = false;\n  stream.end = function () {\n    caughtEnd = true;\n  };\n  stream.pipe = Stream.prototype.pipe;\n  Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n    stream[name] = EventEmitter.prototype[name];\n  });\n  return stream;\n};\nexports.parse = function parse(buffer) {\n  var self = words(function (bytes, cb) {\n    return function (name) {\n      if (offset + bytes <= buffer.length) {\n        var buf = buffer.slice(offset, offset + bytes);\n        offset += bytes;\n        vars.set(name, cb(buf));\n      } else {\n        vars.set(name, null);\n      }\n      return self;\n    };\n  });\n  var offset = 0;\n  var vars = Vars();\n  self.vars = vars.store;\n  self.tap = function (cb) {\n    cb.call(self, vars.store);\n    return self;\n  };\n  self.into = function (key, cb) {\n    if (!vars.get(key)) {\n      vars.set(key, {});\n    }\n    var parent = vars;\n    vars = Vars(parent.get(key));\n    cb.call(self, vars.store);\n    vars = parent;\n    return self;\n  };\n  self.loop = function (cb) {\n    var end = false;\n    var ender = function () {\n      end = true;\n    };\n    while (end === false) {\n      cb.call(self, ender, vars.store);\n    }\n    return self;\n  };\n  self.buffer = function (name, size) {\n    if (typeof size === 'string') {\n      size = vars.get(size);\n    }\n    var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n    offset += size;\n    vars.set(name, buf);\n    return self;\n  };\n  self.skip = function (bytes) {\n    if (typeof bytes === 'string') {\n      bytes = vars.get(bytes);\n    }\n    offset += bytes;\n    return self;\n  };\n  self.scan = function (name, search) {\n    if (typeof search === 'string') {\n      search = new Buffer(search);\n    } else if (!Buffer.isBuffer(search)) {\n      throw new Error('search must be a Buffer or a string');\n    }\n    vars.set(name, null);\n\n    // simple but slow string search\n    for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n      for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++);\n      if (j === search.length) break;\n    }\n    vars.set(name, buffer.slice(offset, offset + i));\n    offset += i + search.length;\n    return self;\n  };\n  self.peek = function (cb) {\n    var was = offset;\n    cb.call(self, vars.store);\n    offset = was;\n    return self;\n  };\n  self.flush = function () {\n    vars.store = {};\n    return self;\n  };\n  self.eof = function () {\n    return offset >= buffer.length;\n  };\n  return self;\n};\n\n// convert byte strings to unsigned little endian numbers\nfunction decodeLEu(bytes) {\n  var acc = 0;\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, i) * bytes[i];\n  }\n  return acc;\n}\n\n// convert byte strings to unsigned big endian numbers\nfunction decodeBEu(bytes) {\n  var acc = 0;\n  for (var i = 0; i < bytes.length; i++) {\n    acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n  }\n  return acc;\n}\n\n// convert byte strings to signed big endian numbers\nfunction decodeBEs(bytes) {\n  var val = decodeBEu(bytes);\n  if ((bytes[0] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n  return val;\n}\n\n// convert byte strings to signed little endian numbers\nfunction decodeLEs(bytes) {\n  var val = decodeLEu(bytes);\n  if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n    val -= Math.pow(256, bytes.length);\n  }\n  return val;\n}\nfunction words(decode) {\n  var self = {};\n  [1, 2, 4, 8].forEach(function (bytes) {\n    var bits = bytes * 8;\n    self['word' + bits + 'le'] = self['word' + bits + 'lu'] = decode(bytes, decodeLEu);\n    self['word' + bits + 'ls'] = decode(bytes, decodeLEs);\n    self['word' + bits + 'be'] = self['word' + bits + 'bu'] = decode(bytes, decodeBEu);\n    self['word' + bits + 'bs'] = decode(bytes, decodeBEs);\n  });\n\n  // word8be(n) == word8le(n) for all n\n  self.word8 = self.word8u = self.word8be;\n  self.word8s = self.word8bs;\n  return self;\n}","map":{"version":3,"names":["Chainsaw","require","EventEmitter","Buffers","Vars","Stream","exports","module","bufOrEm","eventName","Buffer","isBuffer","parse","s","stream","pipe","on","buf","write","end","input","apply","arguments","pending","getBytes","bytes","cb","skip","dispatch","offset","caughtEnd","done","buffers","length","splice","slice","builder","saw","next","self","words","name","vars","set","tap","nest","store","into","key","get","parent","flush","loop","call","bind","buffer","scan","find","search","Error","taken","pos","indexOf","i","Math","max","peek","light","writable","push","prototype","Object","getOwnPropertyNames","forEach","ender","size","min","j","was","eof","decodeLEu","acc","pow","decodeBEu","decodeBEs","val","decodeLEs","decode","bits","word8","word8u","word8be","word8s","word8bs"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/binary/index.js"],"sourcesContent":["var Chainsaw = require('chainsaw');\nvar EventEmitter = require('events').EventEmitter;\nvar Buffers = require('buffers');\nvar Vars = require('./lib/vars.js');\nvar Stream = require('stream').Stream;\n\nexports = module.exports = function (bufOrEm, eventName) {\n    if (Buffer.isBuffer(bufOrEm)) {\n        return exports.parse(bufOrEm);\n    }\n    \n    var s = exports.stream();\n    if (bufOrEm && bufOrEm.pipe) {\n        bufOrEm.pipe(s);\n    }\n    else if (bufOrEm) {\n        bufOrEm.on(eventName || 'data', function (buf) {\n            s.write(buf);\n        });\n        \n        bufOrEm.on('end', function () {\n            s.end();\n        });\n    }\n    return s;\n};\n\nexports.stream = function (input) {\n    if (input) return exports.apply(null, arguments);\n    \n    var pending = null;\n    function getBytes (bytes, cb, skip) {\n        pending = {\n            bytes : bytes,\n            skip : skip,\n            cb : function (buf) {\n                pending = null;\n                cb(buf);\n            },\n        };\n        dispatch();\n    }\n    \n    var offset = null;\n    function dispatch () {\n        if (!pending) {\n            if (caughtEnd) done = true;\n            return;\n        }\n        if (typeof pending === 'function') {\n            pending();\n        }\n        else {\n            var bytes = offset + pending.bytes;\n            \n            if (buffers.length >= bytes) {\n                var buf;\n                if (offset == null) {\n                    buf = buffers.splice(0, bytes);\n                    if (!pending.skip) {\n                        buf = buf.slice();\n                    }\n                }\n                else {\n                    if (!pending.skip) {\n                        buf = buffers.slice(offset, bytes);\n                    }\n                    offset = bytes;\n                }\n                \n                if (pending.skip) {\n                    pending.cb();\n                }\n                else {\n                    pending.cb(buf);\n                }\n            }\n        }\n    }\n    \n    function builder (saw) {\n        function next () { if (!done) saw.next() }\n        \n        var self = words(function (bytes, cb) {\n            return function (name) {\n                getBytes(bytes, function (buf) {\n                    vars.set(name, cb(buf));\n                    next();\n                });\n            };\n        });\n        \n        self.tap = function (cb) {\n            saw.nest(cb, vars.store);\n        };\n        \n        self.into = function (key, cb) {\n            if (!vars.get(key)) vars.set(key, {});\n            var parent = vars;\n            vars = Vars(parent.get(key));\n            \n            saw.nest(function () {\n                cb.apply(this, arguments);\n                this.tap(function () {\n                    vars = parent;\n                });\n            }, vars.store);\n        };\n        \n        self.flush = function () {\n            vars.store = {};\n            next();\n        };\n        \n        self.loop = function (cb) {\n            var end = false;\n            \n            saw.nest(false, function loop () {\n                this.vars = vars.store;\n                cb.call(this, function () {\n                    end = true;\n                    next();\n                }, vars.store);\n                this.tap(function () {\n                    if (end) saw.next()\n                    else loop.call(this)\n                }.bind(this));\n            }, vars.store);\n        };\n        \n        self.buffer = function (name, bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function (buf) {\n                vars.set(name, buf);\n                next();\n            });\n        };\n        \n        self.skip = function (bytes) {\n            if (typeof bytes === 'string') {\n                bytes = vars.get(bytes);\n            }\n            \n            getBytes(bytes, function () {\n                next();\n            });\n        };\n        \n        self.scan = function find (name, search) {\n            if (typeof search === 'string') {\n                search = new Buffer(search);\n            }\n            else if (!Buffer.isBuffer(search)) {\n                throw new Error('search must be a Buffer or a string');\n            }\n            \n            var taken = 0;\n            pending = function () {\n                var pos = buffers.indexOf(search, offset + taken);\n                var i = pos-offset-taken;\n                if (pos !== -1) {\n                    pending = null;\n                    if (offset != null) {\n                        vars.set(\n                            name,\n                            buffers.slice(offset, offset + taken + i)\n                        );\n                        offset += taken + i + search.length;\n                    }\n                    else {\n                        vars.set(\n                            name,\n                            buffers.slice(0, taken + i)\n                        );\n                        buffers.splice(0, taken + i + search.length);\n                    }\n                    next();\n                    dispatch();\n                } else {\n                    i = Math.max(buffers.length - search.length - offset - taken, 0);\n\t\t\t\t}\n                taken += i;\n            };\n            dispatch();\n        };\n        \n        self.peek = function (cb) {\n            offset = 0;\n            saw.nest(function () {\n                cb.call(this, vars.store);\n                this.tap(function () {\n                    offset = null;\n                });\n            });\n        };\n        \n        return self;\n    };\n    \n    var stream = Chainsaw.light(builder);\n    stream.writable = true;\n    \n    var buffers = Buffers();\n    \n    stream.write = function (buf) {\n        buffers.push(buf);\n        dispatch();\n    };\n    \n    var vars = Vars();\n    \n    var done = false, caughtEnd = false;\n    stream.end = function () {\n        caughtEnd = true;\n    };\n    \n    stream.pipe = Stream.prototype.pipe;\n    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {\n        stream[name] = EventEmitter.prototype[name];\n    });\n    \n    return stream;\n};\n\nexports.parse = function parse (buffer) {\n    var self = words(function (bytes, cb) {\n        return function (name) {\n            if (offset + bytes <= buffer.length) {\n                var buf = buffer.slice(offset, offset + bytes);\n                offset += bytes;\n                vars.set(name, cb(buf));\n            }\n            else {\n                vars.set(name, null);\n            }\n            return self;\n        };\n    });\n    \n    var offset = 0;\n    var vars = Vars();\n    self.vars = vars.store;\n    \n    self.tap = function (cb) {\n        cb.call(self, vars.store);\n        return self;\n    };\n    \n    self.into = function (key, cb) {\n        if (!vars.get(key)) {\n            vars.set(key, {});\n        }\n        var parent = vars;\n        vars = Vars(parent.get(key));\n        cb.call(self, vars.store);\n        vars = parent;\n        return self;\n    };\n    \n    self.loop = function (cb) {\n        var end = false;\n        var ender = function () { end = true };\n        while (end === false) {\n            cb.call(self, ender, vars.store);\n        }\n        return self;\n    };\n    \n    self.buffer = function (name, size) {\n        if (typeof size === 'string') {\n            size = vars.get(size);\n        }\n        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));\n        offset += size;\n        vars.set(name, buf);\n        \n        return self;\n    };\n    \n    self.skip = function (bytes) {\n        if (typeof bytes === 'string') {\n            bytes = vars.get(bytes);\n        }\n        offset += bytes;\n        \n        return self;\n    };\n    \n    self.scan = function (name, search) {\n        if (typeof search === 'string') {\n            search = new Buffer(search);\n        }\n        else if (!Buffer.isBuffer(search)) {\n            throw new Error('search must be a Buffer or a string');\n        }\n        vars.set(name, null);\n        \n        // simple but slow string search\n        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {\n            for (\n                var j = 0;\n                j < search.length && buffer[offset+i+j] === search[j];\n                j++\n            );\n            if (j === search.length) break;\n        }\n        \n        vars.set(name, buffer.slice(offset, offset + i));\n        offset += i + search.length;\n        return self;\n    };\n    \n    self.peek = function (cb) {\n        var was = offset;\n        cb.call(self, vars.store);\n        offset = was;\n        return self;\n    };\n    \n    self.flush = function () {\n        vars.store = {};\n        return self;\n    };\n    \n    self.eof = function () {\n        return offset >= buffer.length;\n    };\n    \n    return self;\n};\n\n// convert byte strings to unsigned little endian numbers\nfunction decodeLEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256,i) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to unsigned big endian numbers\nfunction decodeBEu (bytes) {\n    var acc = 0;\n    for (var i = 0; i < bytes.length; i++) {\n        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];\n    }\n    return acc;\n}\n\n// convert byte strings to signed big endian numbers\nfunction decodeBEs (bytes) {\n    var val = decodeBEu(bytes);\n    if ((bytes[0] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\n// convert byte strings to signed little endian numbers\nfunction decodeLEs (bytes) {\n    var val = decodeLEu(bytes);\n    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {\n        val -= Math.pow(256, bytes.length);\n    }\n    return val;\n}\n\nfunction words (decode) {\n    var self = {};\n    \n    [ 1, 2, 4, 8 ].forEach(function (bytes) {\n        var bits = bytes * 8;\n        \n        self['word' + bits + 'le']\n        = self['word' + bits + 'lu']\n        = decode(bytes, decodeLEu);\n        \n        self['word' + bits + 'ls']\n        = decode(bytes, decodeLEs);\n        \n        self['word' + bits + 'be']\n        = self['word' + bits + 'bu']\n        = decode(bytes, decodeBEu);\n        \n        self['word' + bits + 'bs']\n        = decode(bytes, decodeBEs);\n    });\n    \n    // word8be(n) == word8le(n) for all n\n    self.word8 = self.word8u = self.word8be;\n    self.word8s = self.word8bs;\n    \n    return self;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}