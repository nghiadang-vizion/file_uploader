{"ast":null,"code":"var _jsxFileName = \"/Users/dangnghia/Documents/vizion/file-uploader/client/src/components/Preview/index.js\";\nimport { useCallback, useMemo } from \"react\";\nimport readXlsxFile from \"read-excel-file/node\";\nimport sqlite3 from \"sqlite3\";\nimport { open } from \"sqlite\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction convertArrayToObject(arr) {\n  const headers = arr[0];\n  const data = arr.slice(1);\n  const result = [];\n  for (let i = 0; i < data.length; i++) {\n    const currentItem = data[i];\n    const currentObject = {};\n    for (let j = 0; j < headers.length; j++) {\n      const key = isNaN(headers[j]) ? headers[j].replace(/\\s+/g, \"\") : j;\n      currentObject[key] = currentItem[j];\n    }\n    result.push(currentObject);\n  }\n  return result;\n}\nexport const Preview = ({\n  files\n}) => {\n  console.log(\"ðŸš€ ~ file: index.js:2 ~ Preview ~ files:\", files);\n  if (!files) {\n    return null;\n  }\n  async function readAndProcessFile() {\n    let newData;\n    try {\n      const rows = await readXlsxFile(\"./example.xlsx\");\n      const col = rows[0];\n      const convertedArray = col.map(columnName => `${columnName.split(\" \").join(\"\")} TEXT`);\n      const colName = col.map(columnName => `${columnName.split(\" \").join(\"\")}`);\n      open({\n        filename: \"./chinook.db\",\n        driver: sqlite3.Database\n      }).then(async db => {\n        const tableName = \"newTable3\";\n        const table = await db.get(`SELECT name FROM sqlite_master WHERE type='table' AND name='${tableName}'`);\n        newData = convertArrayToObject(rows);\n        // await db.exec(`DROP TABLE ${tableName}`)\n        if (!table) {\n          await db.exec(`CREATE TABLE ${tableName} (${convertedArray.join(\", \")})`);\n          for (const key in newData) {\n            if (Object.hasOwnProperty.call(newData, key)) {\n              const element = newData[key];\n              const values = colName.map(i => `\"${element[i]}\"`).join(\", \");\n              await db.exec(`INSERT INTO ${tableName} (${colName.join(\", \")}) \n            VALUES (${values})`);\n            }\n          }\n        } else {\n          const rowCount = await db.get(`SELECT COUNT(*) FROM ${tableName}`);\n          const excelCount = rows.slice(1).length;\n          if (excelCount > rowCount[\"COUNT(*)\"]) {\n            const newRow = newData[newData.length - 1];\n            const values = colName.map(i => `\"${newRow[i]}\"`).join(\", \");\n            await db.exec(`INSERT INTO ${tableName} (${colName.join(\", \")}) \n              VALUES (${values})`);\n          }\n        }\n      });\n      return newData;\n    } catch (error) {\n      console.error(\"Error reading or processing file:\", error);\n    }\n  }\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      children: `${files.filename}`\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_c = Preview;\nvar _c;\n$RefreshReg$(_c, \"Preview\");","map":{"version":3,"names":["useCallback","useMemo","readXlsxFile","sqlite3","open","jsxDEV","_jsxDEV","Fragment","_Fragment","convertArrayToObject","arr","headers","data","slice","result","i","length","currentItem","currentObject","j","key","isNaN","replace","push","Preview","files","console","log","readAndProcessFile","newData","rows","col","convertedArray","map","columnName","split","join","colName","filename","driver","Database","then","db","tableName","table","get","exec","Object","hasOwnProperty","call","element","values","rowCount","excelCount","newRow","error","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/src/components/Preview/index.js"],"sourcesContent":["import { useCallback, useMemo } from \"react\";\nimport readXlsxFile from \"read-excel-file/node\";\nimport sqlite3 from \"sqlite3\";\nimport { open } from \"sqlite\";\n\nfunction convertArrayToObject(arr) {\n  const headers = arr[0];\n  const data = arr.slice(1);\n  const result = [];\n  for (let i = 0; i < data.length; i++) {\n    const currentItem = data[i];\n    const currentObject = {};\n    for (let j = 0; j < headers.length; j++) {\n      const key = isNaN(headers[j]) ? headers[j].replace(/\\s+/g, \"\") : j;\n      currentObject[key] = currentItem[j];\n    }\n    result.push(currentObject);\n  }\n  return result;\n}\n\nexport const Preview = ({ files }) => {\n  console.log(\"ðŸš€ ~ file: index.js:2 ~ Preview ~ files:\", files);\n  if (!files) {\n    return null;\n  }\n\n  async function readAndProcessFile() {\n    let newData;\n    try {\n      const rows = await readXlsxFile(\"./example.xlsx\");\n      const col = rows[0];\n      const convertedArray = col.map(\n        (columnName) => `${columnName.split(\" \").join(\"\")} TEXT`\n      );\n      const colName = col.map(\n        (columnName) => `${columnName.split(\" \").join(\"\")}`\n      );\n      open({\n        filename: \"./chinook.db\",\n        driver: sqlite3.Database,\n      }).then(async (db) => {\n        const tableName = \"newTable3\";\n        const table = await db.get(\n          `SELECT name FROM sqlite_master WHERE type='table' AND name='${tableName}'`\n        );\n        newData = convertArrayToObject(rows);\n        // await db.exec(`DROP TABLE ${tableName}`)\n        if (!table) {\n          await db.exec(\n            `CREATE TABLE ${tableName} (${convertedArray.join(\", \")})`\n          );\n          for (const key in newData) {\n            if (Object.hasOwnProperty.call(newData, key)) {\n              const element = newData[key];\n              const values = colName.map((i) => `\"${element[i]}\"`).join(\", \");\n              await db.exec(`INSERT INTO ${tableName} (${colName.join(\", \")}) \n            VALUES (${values})`);\n            }\n          }\n        } else {\n          const rowCount = await db.get(`SELECT COUNT(*) FROM ${tableName}`);\n          const excelCount = rows.slice(1).length;\n          if (excelCount > rowCount[\"COUNT(*)\"]) {\n            const newRow = newData[newData.length - 1];\n            const values = colName.map((i) => `\"${newRow[i]}\"`).join(\", \");\n            await db.exec(`INSERT INTO ${tableName} (${colName.join(\", \")}) \n              VALUES (${values})`);\n          }\n        }\n      });\n      return newData;\n    } catch (error) {\n      console.error(\"Error reading or processing file:\", error);\n    }\n  }\n\n  return (\n    <>\n      <span>{`${files.filename}`}</span>\n      <br></br>\n    </>\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}