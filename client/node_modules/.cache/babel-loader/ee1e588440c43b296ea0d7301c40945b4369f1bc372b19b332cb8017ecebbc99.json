{"ast":null,"code":"var Stream = require('stream');\nvar Promise = require('bluebird');\nvar util = require('util');\nvar Buffer = require('./Buffer');\nvar strFunction = 'function';\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = require('readable-stream');\nfunction PullStream() {\n  if (!(this instanceof PullStream)) return new PullStream();\n  Stream.Duplex.call(this, {\n    decodeStrings: false,\n    objectMode: true\n  });\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish', function () {\n    self.finished = true;\n    self.emit('chunk', false);\n  });\n}\nutil.inherits(PullStream, Stream.Duplex);\nPullStream.prototype._write = function (chunk, e, cb) {\n  this.buffer = Buffer.concat([this.buffer, chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n};\n\n// The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\nPullStream.prototype.stream = function (eof, includeEof) {\n  var p = Stream.PassThrough();\n  var done,\n    self = this;\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n  function pull() {\n    var packet;\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0, eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match;\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0, match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0, len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n      if (packet) p.write(packet, function () {\n        if (self.buffer.length === 0 || eof.length && self.buffer.length <= eof.length) cb();\n      });\n    }\n    if (!done) {\n      if (self.finished) {\n        self.removeListener('chunk', pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        return;\n      }\n    } else {\n      self.removeListener('chunk', pull);\n      p.end();\n    }\n  }\n  self.on('chunk', pull);\n  pull();\n  return p;\n};\nPullStream.prototype.pull = function (eof, includeEof) {\n  if (eof === 0) return Promise.resolve('');\n\n  // If we already have the required data in buffer\n  // we can resolve the request immediately\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0, eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  }\n\n  // Otherwise we stream until we have it\n  var buffer = Buffer.from(''),\n    self = this;\n  var concatStream = Stream.Transform();\n  concatStream._transform = function (d, e, cb) {\n    buffer = Buffer.concat([buffer, d]);\n    cb();\n  };\n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function (resolve, reject) {\n    rejectHandler = reject;\n    pullStreamRejectHandler = function (e) {\n      self.__emittedError = e;\n      reject(e);\n    };\n    if (self.finished) return reject(new Error('FILE_ENDED'));\n    self.once('error', pullStreamRejectHandler); // reject any errors from pullstream itself\n    self.stream(eof, includeEof).on('error', reject).pipe(concatStream).on('finish', function () {\n      resolve(buffer);\n    }).on('error', reject);\n  }).finally(function () {\n    self.removeListener('error', rejectHandler);\n    self.removeListener('error', pullStreamRejectHandler);\n  });\n};\nPullStream.prototype._read = function () {};\nmodule.exports = PullStream;","map":{"version":3,"names":["Stream","require","Promise","util","Buffer","strFunction","Writable","prototype","destroy","PullStream","Duplex","call","decodeStrings","objectMode","buffer","from","self","on","finished","emit","inherits","_write","chunk","e","cb","concat","stream","eof","includeEof","p","PassThrough","done","callback","undefined","pull","packet","length","slice","match","indexOf","len","write","removeListener","Error","end","resolve","isNaN","data","concatStream","Transform","_transform","d","rejectHandler","pullStreamRejectHandler","reject","__emittedError","once","pipe","finally","_read","module","exports"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/unzipper/lib/PullStream.js"],"sourcesContent":["var Stream = require('stream');\nvar Promise = require('bluebird');\nvar util = require('util');\nvar Buffer = require('./Buffer');\nvar strFunction = 'function';\n\n// Backwards compatibility for node versions < 8\nif (!Stream.Writable || !Stream.Writable.prototype.destroy)\n  Stream = require('readable-stream');\n\nfunction PullStream() {\n  if (!(this instanceof PullStream))\n    return new PullStream();\n\n  Stream.Duplex.call(this,{decodeStrings:false, objectMode:true});\n  this.buffer = Buffer.from('');\n  var self = this;\n  self.on('finish',function() {\n    self.finished = true;\n    self.emit('chunk',false);\n  });\n}\n\nutil.inherits(PullStream,Stream.Duplex);\n\nPullStream.prototype._write = function(chunk,e,cb) {\n  this.buffer = Buffer.concat([this.buffer,chunk]);\n  this.cb = cb;\n  this.emit('chunk');\n};\n\n\n// The `eof` parameter is interpreted as `file_length` if the type is number\n// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream\nPullStream.prototype.stream = function(eof,includeEof) {\n  var p = Stream.PassThrough();\n  var done,self= this;\n\n  function cb() {\n    if (typeof self.cb === strFunction) {\n      var callback = self.cb;\n      self.cb = undefined;\n      return callback();\n    }\n  }\n\n  function pull() {\n    var packet;\n    if (self.buffer && self.buffer.length) {\n      if (typeof eof === 'number') {\n        packet = self.buffer.slice(0,eof);\n        self.buffer = self.buffer.slice(eof);\n        eof -= packet.length;\n        done = !eof;\n      } else {\n        var match = self.buffer.indexOf(eof);\n        if (match !== -1) {\n          // store signature match byte offset to allow us to reference\n          // this for zip64 offset\n          self.match = match\n          if (includeEof) match = match + eof.length;\n          packet = self.buffer.slice(0,match);\n          self.buffer = self.buffer.slice(match);\n          done = true;\n        } else {\n          var len = self.buffer.length - eof.length;\n          if (len <= 0) {\n            cb();\n          } else {\n            packet = self.buffer.slice(0,len);\n            self.buffer = self.buffer.slice(len);\n          }\n        }\n      }\n      if (packet) p.write(packet,function() {\n        if (self.buffer.length === 0 || (eof.length && self.buffer.length <= eof.length)) cb();\n      });\n    }\n    \n    if (!done) {\n      if (self.finished) {\n        self.removeListener('chunk',pull);\n        self.emit('error', new Error('FILE_ENDED'));\n        return;\n      }\n      \n    } else {\n      self.removeListener('chunk',pull);\n      p.end();\n    }\n  }\n\n  self.on('chunk',pull);\n  pull();\n  return p;\n};\n\nPullStream.prototype.pull = function(eof,includeEof) {\n  if (eof === 0) return Promise.resolve('');\n\n  // If we already have the required data in buffer\n  // we can resolve the request immediately\n  if (!isNaN(eof) && this.buffer.length > eof) {\n    var data = this.buffer.slice(0,eof);\n    this.buffer = this.buffer.slice(eof);\n    return Promise.resolve(data);\n  }\n\n  // Otherwise we stream until we have it\n  var buffer = Buffer.from(''),\n      self = this;\n\n  var concatStream = Stream.Transform();\n  concatStream._transform = function(d,e,cb) {\n    buffer = Buffer.concat([buffer,d]);\n    cb();\n  };\n  \n  var rejectHandler;\n  var pullStreamRejectHandler;\n  return new Promise(function(resolve,reject) {\n    rejectHandler = reject;\n    pullStreamRejectHandler = function(e) {\n      self.__emittedError = e;\n      reject(e);\n    }\n    if (self.finished)\n      return reject(new Error('FILE_ENDED'));\n    self.once('error',pullStreamRejectHandler);  // reject any errors from pullstream itself\n    self.stream(eof,includeEof)\n      .on('error',reject)\n      .pipe(concatStream)\n      .on('finish',function() {resolve(buffer);})\n      .on('error',reject);\n  })\n  .finally(function() {\n    self.removeListener('error',rejectHandler);\n    self.removeListener('error',pullStreamRejectHandler);\n  });\n};\n\nPullStream.prototype._read = function(){};\n\nmodule.exports = PullStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}