{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Statement = void 0;\nconst format_error_1 = require(\"./utils/format-error\");\n/**\n * Promisified wrapper for the sqlite3#Statement interface.\n */\nclass Statement {\n  constructor(stmt) {\n    this.stmt = stmt;\n  }\n  /**\n   * Returns the underlying sqlite3 Statement instance\n   */\n  getStatementInstance() {\n    return this.stmt;\n  }\n  /**\n   * Binds parameters to the prepared statement.\n   *\n   * Binding parameters with this function completely resets the statement object and row cursor\n   * and removes all previously bound parameters, if any.\n   */\n  bind(...params) {\n    return new Promise((resolve, reject) => {\n      this.stmt.bind(...params, err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve();\n      });\n    });\n  }\n  /**\n   * Resets the row cursor of the statement and preserves the parameter bindings.\n   * Use this function to re-execute the same query with the same bindings.\n   */\n  reset() {\n    return new Promise(resolve => {\n      this.stmt.reset(() => {\n        resolve();\n      });\n    });\n  }\n  /**\n   * Finalizes the statement. This is typically optional, but if you experience long delays before\n   * the next query is executed, explicitly finalizing your statement might be necessary.\n   * This might be the case when you run an exclusive query (see section Control Flow).\n   * After the statement is finalized, all further function calls on that statement object\n   * will throw errors.\n   */\n  finalize() {\n    return new Promise((resolve, reject) => {\n      this.stmt.finalize(err => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve();\n      });\n    });\n  }\n  /**\n   * Binds parameters and executes the statement.\n   *\n   * If you specify bind parameters, they will be bound to the statement before it is executed.\n   * Note that the bindings and the row cursor are reset when you specify even a single bind parameter.\n   *\n   * The execution behavior is identical to the Database#run method with the difference that the\n   * statement will not be finalized after it is run. This means you can run it multiple times.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n  run(...params) {\n    return new Promise((resolve, reject) => {\n      const stmt = this;\n      this.stmt.run(...params, function (err) {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve({\n          stmt,\n          lastID: this.lastID,\n          changes: this.changes\n        });\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and retrieves the first result row.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * Using this method can leave the database locked, as the database awaits further\n   * calls to Statement#get to retrieve subsequent rows. To inform the database that you\n   * are finished retrieving rows, you should either finalize (with Statement#finalize)\n   * or reset (with Statement#reset) the statement.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   */\n  get(...params) {\n    return new Promise((resolve, reject) => {\n      this.stmt.get(...params, (err, row) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(row);\n      });\n    });\n  }\n  /**\n   * Binds parameters, executes the statement and calls the callback with all result rows.\n   * The parameters are the same as the Statement#run function, with the following differences:\n   *\n   * If the result set is empty, it will resolve to an empty array, otherwise it contains an\n   * object for each result row which in turn contains the values of that row.\n   * Like with Statement#run, the statement will not be finalized after executing this function.\n   *\n   * @param {any} [params, ...] When the SQL statement contains placeholders, you\n   * can pass them in here. They will be bound to the statement before it is\n   * executed. There are three ways of passing bind parameters: directly in\n   * the function's arguments, as an array, and as an object for named\n   * parameters. This automatically sanitizes inputs.\n   *\n   * @see https://github.com/mapbox/node-sqlite3/wiki/API#databaseallsql-param--callback\n   */\n  all(...params) {\n    return new Promise((resolve, reject) => {\n      this.stmt.all(...params, (err, rows) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(rows);\n      });\n    });\n  }\n  each(...params) {\n    return new Promise((resolve, reject) => {\n      const callback = params.pop();\n      if (!callback || typeof callback !== 'function') {\n        throw new Error('sqlite: Last param of Statement#each() must be a callback function');\n      }\n      if (params.length > 0) {\n        const positional = params.pop();\n        if (typeof positional === 'function') {\n          throw new Error('sqlite: Statement#each() should only have a single callback defined. See readme for usage.');\n        }\n        params.push(positional);\n      }\n      this.stmt.each(...params, (err, row) => {\n        if (err) {\n          return callback((0, format_error_1.formatError)(err), null);\n        }\n        callback(null, row);\n      }, (err, count) => {\n        if (err) {\n          return reject((0, format_error_1.formatError)(err));\n        }\n        resolve(count);\n      });\n    });\n  }\n}\nexports.Statement = Statement;","map":{"version":3,"names":["format_error_1","require","Statement","constructor","stmt","getStatementInstance","bind","params","Promise","resolve","reject","err","formatError","reset","finalize","run","lastID","changes","get","row","all","rows","each","callback","pop","Error","length","positional","push","count","exports"],"sources":["../src/Statement.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}