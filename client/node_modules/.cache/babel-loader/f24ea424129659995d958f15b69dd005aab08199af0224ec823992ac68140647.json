{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport NumberType from '../../types/Number.js';\nimport StringType from '../../types/String.js';\nimport BooleanType from '../../types/Boolean.js';\nimport DateType from '../../types/Date.js';\nvar DEFAULT_OPTIONS = {\n  isColumnOriented: false\n};\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\n\nexport default function (data, schema, options) {\n  if (options) {\n    options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n  } else {\n    options = DEFAULT_OPTIONS;\n  }\n  var _options = options,\n    isColumnOriented = _options.isColumnOriented,\n    rowMap = _options.rowMap,\n    ignoreEmptyRows = _options.ignoreEmptyRows;\n  validateSchema(schema);\n  if (isColumnOriented) {\n    data = transpose(data);\n  }\n  var columns = data[0];\n  var results = [];\n  var errors = [];\n  for (var i = 1; i < data.length; i++) {\n    var result = read(schema, data[i], i, columns, errors, options);\n    if (result !== null || ignoreEmptyRows === false) {\n      results.push(result);\n    }\n  } // Correct error rows.\n\n  if (rowMap) {\n    for (var _iterator = _createForOfIteratorHelperLoose(errors), _step; !(_step = _iterator()).done;) {\n      var error = _step.value;\n      // Convert the `row` index in `data` to the\n      // actual `row` index in the spreadsheet.\n      // `- 1` converts row number to row index.\n      // `+ 1` converts row index to row number.\n      error.row = rowMap[error.row - 1] + 1;\n    }\n  }\n  return {\n    rows: results,\n    errors: errors\n  };\n}\nfunction read(schema, row, rowIndex, columns, errors, options) {\n  var object = {};\n  var isEmptyObject = true;\n  var createError = function createError(_ref) {\n    var column = _ref.column,\n      value = _ref.value,\n      errorMessage = _ref.error,\n      reason = _ref.reason;\n    var error = {\n      error: errorMessage,\n      row: rowIndex + 1,\n      column: column,\n      value: value\n    };\n    if (reason) {\n      error.reason = reason;\n    }\n    if (schema[column].type) {\n      error.type = schema[column].type;\n    }\n    return error;\n  };\n  var pendingRequiredChecks = [];\n  var _loop = function _loop() {\n    var key = _Object$keys[_i];\n    var schemaEntry = schema[key];\n    var isNestedSchema = _typeof(schemaEntry.type) === 'object' && !Array.isArray(schemaEntry.type);\n    var rawValue = row[columns.indexOf(key)];\n    if (rawValue === undefined) {\n      rawValue = null;\n    }\n    var value = void 0;\n    var error = void 0;\n    var reason = void 0;\n    if (isNestedSchema) {\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options);\n    } else {\n      if (rawValue === null) {\n        value = null;\n      } else if (Array.isArray(schemaEntry.type)) {\n        var notEmpty = false;\n        var array = parseArray(rawValue).map(function (_value) {\n          var result = parseValue(_value, schemaEntry, options);\n          if (result.error) {\n            value = _value;\n            error = result.error;\n            reason = result.reason;\n          }\n          if (result.value !== null) {\n            notEmpty = true;\n          }\n          return result.value;\n        });\n        if (!error) {\n          value = notEmpty ? array : null;\n        }\n      } else {\n        var result = parseValue(rawValue, schemaEntry, options);\n        error = result.error;\n        reason = result.reason;\n        value = error ? rawValue : result.value;\n      }\n    }\n    if (!error && value === null) {\n      if (typeof schemaEntry.required === 'function') {\n        pendingRequiredChecks.push({\n          column: key\n        });\n      } else if (schemaEntry.required === true) {\n        error = 'required';\n      }\n    }\n    if (error) {\n      errors.push(createError({\n        column: key,\n        value: value,\n        error: error,\n        reason: reason\n      }));\n    } else {\n      if (isEmptyObject && value !== null) {\n        isEmptyObject = false;\n      }\n      if (value !== null || options.includeNullValues) {\n        object[schemaEntry.prop] = value;\n      }\n    }\n  };\n  for (var _i = 0, _Object$keys = Object.keys(schema); _i < _Object$keys.length; _i++) {\n    _loop();\n  }\n  if (isEmptyObject) {\n    return null;\n  }\n  for (var _i2 = 0, _pendingRequiredCheck = pendingRequiredChecks; _i2 < _pendingRequiredCheck.length; _i2++) {\n    var column = _pendingRequiredCheck[_i2].column;\n    var required = schema[column].required(object);\n    if (required) {\n      errors.push(createError({\n        column: column,\n        value: null,\n        error: 'required'\n      }));\n    }\n  }\n  return object;\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\n\nexport function parseValue(value, schemaEntry, options) {\n  if (value === null) {\n    return {\n      value: null\n    };\n  }\n  var result;\n  if (schemaEntry.parse) {\n    result = parseCustomValue(value, schemaEntry.parse);\n  } else if (schemaEntry.type) {\n    result = parseValueOfType(value,\n    // Supports parsing array types.\n    // See `parseArray()` function for more details.\n    // Example `type`: String[]\n    // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\n    // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\n    Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options);\n  } else {\n    result = {\n      value: value\n    }; // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\n  } // If errored then return the error.\n\n  if (result.error) {\n    return result;\n  }\n  if (result.value !== null) {\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\n      return {\n        error: 'invalid',\n        reason: 'unknown'\n      };\n    }\n    if (schemaEntry.validate) {\n      try {\n        schemaEntry.validate(result.value);\n      } catch (error) {\n        return {\n          error: error.message\n        };\n      }\n    }\n  }\n  return result;\n}\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\n\nfunction parseCustomValue(value, parse) {\n  try {\n    value = parse(value);\n    if (value === undefined) {\n      return {\n        value: null\n      };\n    }\n    return {\n      value: value\n    };\n  } catch (error) {\n    var result = {\n      error: error.message\n    };\n    if (error.reason) {\n      result.reason = error.reason;\n    }\n    return result;\n  }\n}\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\n\nfunction parseValueOfType(value, type, options) {\n  switch (type) {\n    case String:\n      return parseCustomValue(value, StringType);\n    case Number:\n      return parseCustomValue(value, NumberType);\n    case Date:\n      return parseCustomValue(value, function (value) {\n        return DateType(value, {\n          properties: options.properties\n        });\n      });\n    case Boolean:\n      return parseCustomValue(value, BooleanType);\n    default:\n      if (typeof type === 'function') {\n        return parseCustomValue(value, type);\n      }\n      throw new Error(\"Unsupported schema type: \".concat(type && type.name || type));\n  }\n}\nexport function getBlock(string, endCharacter, startIndex) {\n  var i = 0;\n  var substring = '';\n  var character;\n  while (startIndex + i < string.length) {\n    var _character = string[startIndex + i];\n    if (_character === endCharacter) {\n      return [substring, i];\n    } else if (_character === '\"') {\n      var block = getBlock(string, '\"', startIndex + i + 1);\n      substring += block[0];\n      i += '\"'.length + block[1] + '\"'.length;\n    } else {\n      substring += _character;\n      i++;\n    }\n  }\n  return [substring, i];\n}\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\n\nexport function parseArray(string) {\n  var blocks = [];\n  var index = 0;\n  while (index < string.length) {\n    var _getBlock = getBlock(string, ',', index),\n      _getBlock2 = _slicedToArray(_getBlock, 2),\n      substring = _getBlock2[0],\n      length = _getBlock2[1];\n    index += length + ','.length;\n    blocks.push(substring.trim());\n  }\n  return blocks;\n} // Transpose a 2D array.\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\n\nvar transpose = function transpose(array) {\n  return array[0].map(function (_, i) {\n    return array.map(function (row) {\n      return row[i];\n    });\n  });\n};\nfunction validateSchema(schema) {\n  for (var _i3 = 0, _Object$keys2 = Object.keys(schema); _i3 < _Object$keys2.length; _i3++) {\n    var key = _Object$keys2[_i3];\n    var entry = schema[key];\n    if (!entry.prop) {\n      throw new Error(\"\\\"prop\\\" not defined for schema entry \\\"\".concat(key, \"\\\".\"));\n    }\n  }\n}","map":{"version":3,"names":["NumberType","StringType","BooleanType","DateType","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","_objectSpread","_options","rowMap","ignoreEmptyRows","validateSchema","transpose","columns","results","errors","i","length","result","read","push","_iterator","_createForOfIteratorHelperLoose","_step","done","error","value","row","rows","rowIndex","object","isEmptyObject","createError","_ref","column","errorMessage","reason","type","pendingRequiredChecks","_loop","key","_Object$keys","_i","schemaEntry","isNestedSchema","_typeof","Array","isArray","rawValue","indexOf","undefined","notEmpty","array","parseArray","map","_value","parseValue","required","includeNullValues","prop","Object","keys","_i2","_pendingRequiredCheck","parse","parseCustomValue","parseValueOfType","oneOf","validate","message","String","Number","Date","properties","Boolean","Error","concat","name","getBlock","string","endCharacter","startIndex","substring","character","_character","block","blocks","index","_getBlock","_getBlock2","_slicedToArray","trim","_","_i3","_Object$keys2","entry"],"sources":["/Users/dangnghia/Documents/vizion/file-uploader/client/node_modules/read-excel-file/source/read/schema/convertToJson.js"],"sourcesContent":["import NumberType from '../../types/Number.js'\r\nimport StringType from '../../types/String.js'\r\nimport BooleanType from '../../types/Boolean.js'\r\nimport DateType from '../../types/Date.js'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {any[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap,\r\n    ignoreEmptyRows\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i, columns, errors, options)\r\n    if (result !== null || ignoreEmptyRows === false) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      // Convert the `row` index in `data` to the\r\n      // actual `row` index in the spreadsheet.\r\n      // `- 1` converts row number to row index.\r\n      // `+ 1` converts row index to row number.\r\n      error.row = rowMap[error.row - 1] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  let isEmptyObject = true\r\n\r\n  const createError = ({\r\n    column,\r\n    value,\r\n    error: errorMessage,\r\n    reason\r\n  }) => {\r\n    const error = {\r\n      error: errorMessage,\r\n      row: rowIndex + 1,\r\n      column,\r\n      value\r\n    }\r\n    if (reason) {\r\n      error.reason = reason\r\n    }\r\n    if (schema[column].type) {\r\n      error.type = schema[column].type\r\n    }\r\n    return error\r\n  }\r\n\r\n  const pendingRequiredChecks = []\r\n\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n\r\n    let value\r\n    let error\r\n    let reason\r\n\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n            reason = result.reason\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        reason = result.reason\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n\r\n    if (!error && value === null) {\r\n      if (typeof schemaEntry.required === 'function') {\r\n        pendingRequiredChecks.push({ column: key })\r\n      } else if (schemaEntry.required === true) {\r\n        error = 'required'\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      errors.push(createError({\r\n        column: key,\r\n        value,\r\n        error,\r\n        reason\r\n      }))\r\n    } else {\r\n      if (isEmptyObject && value !== null) {\r\n        isEmptyObject = false\r\n      }\r\n      if (value !== null || options.includeNullValues) {\r\n        object[schemaEntry.prop] = value\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isEmptyObject) {\r\n    return null\r\n  }\r\n\r\n  for (const { column } of pendingRequiredChecks) {\r\n    const required = schema[column].required(object)\r\n    if (required) {\r\n      errors.push(createError({\r\n        column,\r\n        value: null,\r\n        error: 'required'\r\n      }))\r\n    }\r\n  }\r\n\r\n  return object\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(\r\n      value,\r\n      // Supports parsing array types.\r\n      // See `parseArray()` function for more details.\r\n      // Example `type`: String[]\r\n      // Input: 'Barack Obama, \"String, with, colons\", Donald Trump'\r\n      // Output: ['Barack Obama', 'String, with, colons', 'Donald Trump']\r\n      Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type,\r\n      options\r\n    )\r\n  } else {\r\n    result = { value: value }\r\n    // throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null) {\r\n    if (schemaEntry.oneOf && schemaEntry.oneOf.indexOf(result.value) < 0) {\r\n      return { error: 'invalid', reason: 'unknown' }\r\n    }\r\n    if (schemaEntry.validate) {\r\n      try {\r\n        schemaEntry.validate(result.value)\r\n      } catch (error) {\r\n        return { error: error.message }\r\n      }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {any} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    value = parse(value)\r\n    if (value === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value }\r\n  } catch (error) {\r\n    const result = { error: error.message }\r\n    if (error.reason) {\r\n      result.reason = error.reason;\r\n    }\r\n    return result\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {any} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string, reason?: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return parseCustomValue(value, StringType)\r\n\r\n    case Number:\r\n      return parseCustomValue(value, NumberType)\r\n\r\n    case Date:\r\n      return parseCustomValue(value, (value) => DateType(value, { properties: options.properties }))\r\n\r\n    case Boolean:\r\n      return parseCustomValue(value, BooleanType)\r\n\r\n    default:\r\n      if (typeof type === 'function') {\r\n        return parseCustomValue(value, type)\r\n      }\r\n      throw new Error(`Unsupported schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\n/**\r\n * Parses a string of comma-separated substrings into an array of substrings.\r\n * (the `export` is just for tests)\r\n * @param  {string} string — A string of comma-separated substrings.\r\n * @return {string[]} An array of substrings.\r\n */\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}